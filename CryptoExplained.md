A Simple Guide to Your Cryptography AlgorithmsYou've got a list of 11 problems in cryptography. Let's walk through what each one is actually doing, without the scary math terms.1. Shift Cipher (or Caesar Cipher)The Big Idea: This is the "decoder ring" you'd get in a cereal box.Simple Analogy: Imagine the alphabet written on a paper wheel, and another one inside it. To "encrypt," you just shift the inner wheel by a secret number (the "key").How it Works:You pick a secret key, say, 3.A becomes D (A + 3 = D)B becomes E (B + 3 = E)HELLO becomes KHOOR.Decryption: You just shift back by 3. KHOOR becomes HELLO.Brute Force: Since there are only 26 letters, there are only 25 useful keys (a key of 26 is the same as a key of 0). To "brute force" it, you just try all 25 possible shifts until one of them makes sense.2. Multiplicative CipherThe Big Idea: Instead of sliding the alphabet, you jump through it.How it Works:You give each letter a number (A=0, B=1, ... Z=25).You pick a secret key (a number), say 7.You multiply the letter's number by the key.B is 1. 1 * 7 = 7. 7 is H. So, B becomes H.D is 3. 3 * 7 = 21. 21 is V. So, D becomes V.Key Constraint: The "key" must be a number that is coprime with 26. This is a fancy way of-saying it doesn't share any factors with 26 (other than 1). This is to make sure you can always decrypt it. If you used 2 as a key, both A (0) and M (12) would become A (0 * 2 = 0, 12 * 2 = 24... oh wait, 24 is Y. Bad example. A(0) and N(13). A -> 0 * 2 = 0 (A). N -> 13 * 2 = 26, which is 0 (A). Both A and N become A. You can't decrypt that!). The valid keys are {1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25}.Decryption: You need a "magic reverse number" called a modular multiplicative inverse. It's the number that, when multiplied by your key, gets you back to 1. For our key 7, the inverse is 15 (because 7 * 15 = 105, and 105 % 26 = 1).Brute Force: You just try all 12 of the valid keys.3. Affine CipherThe Big Idea: This cipher just does both of the first two.How it Works: It uses two keys.First, you multiply by key1 (like the Multiplicative Cipher).Then, you add key2 (like the Shift Cipher).Formula: Cipher = (Plaintext * key1 + key2) % 26Key Constraints: key1 must be one of the 12 "coprime" keys. key2 can be any number from 0 to 25.Security: This is stronger than the first two, but still very weak.Brute Force: You just try all possible pairs of keys. There are 12 choices for key1 and 26 for key2, so 12 * 26 = 312 total guesses. A computer can do this instantly.4. Autokey Cipher (Vigenère family)The Big Idea: The problem describes a polyalphabetic cipher. The "initial key" is a keyword, and the "other keys are generated automatically" by using the plaintext message itself as the rest of the key. This is the Autokey Cipher.How it Works: This is a Shift Cipher where the shift amount changes for every letter.Message: MEET ME AFTER TOGA PARTYKeyword: RUSTOMAutokey: RUSTOM**MEETMEAFTERTOGAP** (The key starts with RUSTOM, then is extended by the message MEETME...)Now you encrypt one letter at a time, using the corresponding key letter as the "shift amount".M (12) + R (17) = 29 % 26 = 3 (D)E (4) + U (20) = 24 % 26 = 24 (Y)E (4) + S (18) = 22 % 26 = 22 (W)...and so on.Security: This is much stronger than the first three because the same letter (E) encrypts to a different letter each time (Y and W in our example). This breaks simple "frequency analysis" (where E is the most common letter).Brute Force: A "brute force" in the same way (trying all keys) is not possible, as the key is as long as the message. An attacker would have to guess the keyword and its length, which is much, much harder.5. Playfair CipherThe Big Idea: Encrypts pairs of letters at a time, using a 5x5 grid.How it Works:Create a 5x5 Grid: You fill a 5x5 grid with a keyword (no repeating letters), then fill the rest with the alphabet. Since there are 25 squares, I and J are put in the same square.Prepare the Message: Break the message into pairs of letters (ME ET ME AF TE RT OG AP AR TY).If a pair has the same letter (like HELLO -> HE LL O), add an X: HE LX LO.If there's an odd letter at the end, add an X: HE LX LO XZ.Encrypt the Pairs: Find the two letters in your grid and follow 3 rules:Same Row: Take the letters to their right (wrap around).Same Column: Take the letters below them (wrap around).Rectangle: Form a rectangle. Take the letters at the other two corners (on the same row).Security: Even stronger. It hides single-letter frequencies and encrypts 600+ possible pairs (25 * 24), not just 26 letters.6. Hill CipherThe Big Idea: Uses "matrix math" to encrypt blocks of letters.How it Works:You pick a key matrix (e.g., a 2x2 grid of numbers).You turn your message into pairs of numbers (vectors). HI -> [7, 8].You use matrix multiplication: Key_Matrix * [7, 8] = [New_Num1, New_Num2].These new numbers are your ciphertext letters.Decryption: You need the inverse of your key matrix. You multiply the ciphertext vectors by this "reverse matrix" to get the plaintext back.Security: Very strong... if the key is big (e.g., 3x3 or 4x4). It encrypts multiple letters at once, completely scrambling the language patterns. Its weakness is that it's vulnerable to a "known-plaintext attack" (if you know some of the original message, you can solve for the matrix).7. ElGamal CryptosystemThe Big Idea: This is a "two-key" system, also called Asymmetric Cryptography.Simple Analogy: Imagine you have a special public padlock. You can make copies and give them to everyone. Anyone can use your padlock to lock a box. But only you have the private key that can open it.ShutterstockHow itWorks:Key Generation: You pick a giant private number x and do some hard math to create a public number y.Public Key: (y, g, p) - You post this on the internet.Private Key: (x) - You never tell anyone this.Encryption: Alice uses your public key to turn her message M into two ciphertext numbers, C1 and C2.Decryption: You use your private key x with C1 and C2 to get M back.Security: Based on a "hard problem" called the Discrete Logarithm Problem. It's easy to do g^x to get y, but it's impossibly hard for a computer to find x if they only know y, g, and p.8. Rabin-Miller Primality TestThe Big Idea: A way to check if a gigantic number is prime (only divisible by 1 and itself).Why? All modern crypto (like ElGamal, RSA) needs giant prime numbers.How it Works: You can't just try dividing. A 200-digit number would take longer than the age of the universe to check.Simple Analogy: It's a "spot check." Imagine you're a bouncer at a club for "Prime Numbers Only." Instead of a full body search (trial division), you ask a few very clever questions.If the number fails even one question, you know for sure it's "composite" (not prime) and you kick it out.If it passes all (say) 20 questions, you can't be 100% sure, but you are so sure (like 99.999...9%) that it's prime, you let it in.This is a probabilistic test. It's not a "yes/no," it's a "definitely no" or a "very, very probably yes."9. Diffie-Hellman Key ExchangeThe Big Idea: A "magic trick" for two people (Alice and Bob) to create a shared secret key over a public channel (where an enemy, Eve, is listening) without ever sending the key.This is NOT encryption. It's a way to agree on a key to use for other encryption (like a Shift Cipher, but with a huge key).Simple Analogy (The Paint Mixing Trick):Public: Alice and Bob agree on a "public" paint color: Yellow.Private: Alice picks a secret color (Red). Bob picks a secret color (Blue).Exchange:Alice mixes Yellow + Red to get Orange. She sends Orange to Bob.Bob mixes Yellow + Blue to get Green. He sends Green to Alice.Eve Sees: The listener (Eve) sees Orange and Green go by, but not the secret colors (Red or Blue).Create Secret:Alice gets Green and mixes in her secret color (Red). Green + Red = (Yellow + Blue) + Red = **Brown**.Bob gets Orange and mixes in his secret color (Blue). Orange + Blue = (Yellow + Red) + Blue = **Brown**.Result: Both Alice and Bob have the exact same secret color (Brown), and Eve has no idea what it is!The "paint" is math with giant numbers (g^a mod p).10. RSA Algorithm (Rivest–Shamir–Adleman)The Big Idea: The most famous two-key (asymmetric) system.How it Works:Key Generation:Alice secretly picks two huge prime numbers, p and q. (She uses Rabin-Miller to find them!)She multiplies them: n = p * q.She does some math to get her Public Key (e, n) and her Private Key (d, n).Encryption: Bob wants to send "HELLO" to Alice.He looks up her Public Key (e, n).He runs the message through the formula: Cipher = (Message)^e mod n.Decryption: Alice gets the ciphertext.She uses her Private Key (d, n).Formula: Message = (Cipher)^d mod n.Security: Based on the Factoring Problem. It's easy to multiply p and q to get n. But if n is 600 digits long, it is impossible for anyone to find the original p and q. Your private key d depends on p and q, so only you (who made them) can have it.Shutterstock11. RSA Digital SignatureThe Big Idea: Uses RSA "in reverse" to prove a message came from you and wasn't changed. This is for Authentication, not Secrecy.Simple Analogy: A "digital wax seal."How it Works:Alice signs:She writes her message: "This is an example".She creates a "fingerprint" of the message called a hash (a short, unique string, like a5f8...).She "encrypts" the hash with her PRIVATE KEY. This is the signature.Alice sends: The (plain, unencrypted) message + the signature.Bob verifies:He gets the message and the signature.He creates his own hash of the message.He "decrypts" the signature using Alice's PUBLIC KEY.Compare: If his hash matches the decrypted signature, he knows two things:It's from Alice: Only her private key could have created a signature that her public key could open.It wasn't tampered with: If even one letter of the message changed, the hash would be totally different.